namespace Instructions{

  enum flag{
    Z = 7,
    N = 6,
    H = 5,
    C = 4
  };

  enum opcodes{
    NOP = 0x00, // Null Instruction
    LD_BC_N16 = 0x01, // Load 16bit number to BC
    LD_BC_A = 0x02, // Load accumulator to BC
    INC_BC = 0x03, // Increment BC
    INC_B = 0x04, // Increment B
    DEC_B = 0x05, // Decrement B
    LD_B_N8 = 0x06, // Load 8bit number to B
    RLCA = 0x07, // Rotate A Left
    LD_N16_SP = 0x08, // Load Stack Pointer to 16bit register
    ADD_HL_BC = 0x09, // Add BC to HL
    LD_A_BC = 0x0A, // Load the contents in the address of BC to A
    DEC_BC = 0x0B, // Decrements BC
    INC_C = 0x0C, // Increments C
    DEC_C = 0x0D, // Decrements C
    LD_C_N8 = 0x0E, // Loads 8bit number to C
    RRCA = 0x0F, // Rotate a Right

    STOP_N8 = 0x10, // Halts the CPU until any button is pressed
    LD_DE_N16 = 0x011, // Loads 16bit number to DE
    LD_DE_A = 0x12, // Loads A into DE
    INC_DE = 0x13, // Increments DE
    INC_D = 0x14, // Increments D
    DEC_D = 0x15, // Decrements D
    LD_D_N8 = 0x16, // Load 8bit number to D
    RLA = 0x17, // Rotate A Left through carry flag
    JR_E8 = 0x18, // Add 8bit signed to current address and Jump to it
    ADD_HL_DE = 0x19, // Add DE to HL
    LD_A_DE = 0x1A, // Load the contents in the address of DE to A
    DEC_DE = 0x1B, // Decrements DE
    INC_E = 0x1C, // Increments E
    DEC_E = 0x1D, // Decrements E
    LD_E_N8 = 0x1E, // Load 8bit number to E
    RRA = 0x1F, // Rotate A Right trough carry flag

    JR_NZ_E8 = 0x20, // Add 8bit signed to current address and Jump to it if Z Flag is reset
    LD_HL_N16 = 0x21, // Load 16bit number into HL
    LD_HLI_A = 0x22, // Load A into HL and increments HL
    INC_HL = 0x23, // Increments HL
    INC_H = 0x24, // Increments H
    DEC_H = 0x25, // Decrements H
    LD_H_N8 = 0x26, // Loads 8bit number into H
    DAA = 0x27, // Adjusts A so the correct representation of the Binary Coded Decimal is obtained
    JR_Z_E8 = 0x28, // Add 8bit signed to current address and Jump to it if Z Flag is set
    ADD_HL_HL = 0x29, // Add HL to HL
    LD_A_HLI = 0x2A, // Load the memory pointed by HL into A and then increments HL
    DEC_HL = 0x2B, // Decrements HL
    INC_L = 0x2C, // Increments L
    DEC_L = 0x2D, // Decrements L
    LD_L_N8 = 0x2E, // Load 8bit number into L
    CPL = 0x2F, // Flips all bits in the A register

    JR_NC_E8 = 0x30, // Add 8bit signed to current address and Jump to it if C Flag is reset
    LD_SP_N16 = 0x31, // Load 8bit number into SP
    LD_HLD_A = 0x32, // Load A into HL and decrements HL
    INC_SP = 0x33, // Increments SP
    INC_PTR_HL = 0x34, // Increments HL
    DEC_PTR_HL = 0x35, // Decrements HL
    LD_HL_N8 = 0x36, // load 8bit number into HL
    SCF = 0x37, // Sets the Carry flag
    JR_C_E8 = 0x38, // Add 8bit signed to current address and Jump to it if carry flag is set
    ADD_HL_SP = 0x39, // Add Sp to HL
    LD_A_HLD = 0x3A, // Load the memory pointed by HL into A and then decrements HL
    DEC_SP = 0x3B, // Decrements SP
    INC_A = 0x3C, // Increment A
    DEC_A = 0x3D, // Decrement A
    LD_A_N8 = 0x3E, // Load 8bit number into A
    CCF = 0xCF, // Complements the carry flag

    LD_B_B = 0x40, // Load B into B (NOP)
    LD_B_C = 0x41, // Load C into B
    LD_B_D = 0x42, // Load D into B
    LD_B_E = 0x43, // Load E into B
    LD_B_H = 0x44, // Load H into B
    LD_B_L = 0x45, // Load L into B
    LD_B_HL = 0x46, // Load the memory pointed by HL into B
    LD_B_A = 0x47, // Load A into B
    LD_C_B = 0x48, // Load B into C 
    LD_C_C = 0x49, // Load C into C (NOP)
    LD_C_D = 0x4A, // Load D into C
    LD_C_E = 0x4B, // Load E into C
    LD_C_H = 0x4C, // Load H into C
    LD_C_L = 0x4D, // Load L into C
    LD_C_HL = 0x4E, // Load the memory pointed by HL into C
    LD_C_A = 0x4F, // Load A into C

    LD_D_B = 0x50, // Load B into D
    LD_D_C = 0x51, // Load C into D
    LD_D_D = 0x52, // Load D into D (NOP)
    LD_D_E = 0x53, // Load E into D
    LD_D_H = 0x54, // Load H into D
    LD_D_L = 0x55, // Load L into D
    LD_D_HL = 0x56, // Load the memory pointed by HL into D
    LD_D_A = 0x57, // Load A into D
    LD_E_B = 0x58, // Load B into E 
    LD_E_C = 0x59, // Load C into E
    LD_E_D = 0x5A, // Load D into E
    LD_E_E = 0x5B, // Load E into E (NOP)
    LD_E_H = 0x5C, // Load H into E
    LD_E_L = 0x5D, // Load L into E
    LD_E_HL = 0x5E, // Load the memory pointed by HL into E
    LD_E_A = 0x5F, // Load A into E

    LD_H_B = 0x60, // Load B into H
    LD_H_C = 0x61, // Load C into H
    LD_H_D = 0x62, // Load D into H 
    LD_H_E = 0x63, // Load E into H
    LD_H_H = 0x64, // Load H into H (NOP)
    LD_H_L = 0x65, // Load L into H
    LD_H_HL = 0x66, // Load the memory pointed by HL into H
    LD_H_A = 0x67, // Load A into H
    LD_L_B = 0x68, // Load B into L 
    LD_L_C = 0x69, // Load C into L
    LD_L_D = 0x6A, // Load D into L
    LD_L_E = 0x6B, // Load E into L
    LD_L_H = 0x6C, // Load H into L
    LD_L_L = 0x6D, // Load L into L (NOP)
    LD_L_HL = 0x6E, // Load the memory pointed by HL into L
    LD_L_A = 0x6F, // Load A into L

    LD_HL_B = 0x70, // Load B into HL
    LD_HL_C = 0x71, // Load C into HL
    LD_HL_D = 0x72, // Load D into HL
    LD_HL_E = 0x73, // Load E into HL
    LD_HL_H = 0x74, // Load H into HL
    LD_HL_L = 0x75, // Load L into HL
    HALT = 0x76, // Halts the CPU until an interrupt occurs
    LD_HL_A = 0x77, // Load A into HL
    LD_A_B = 0x78, // Load B into A 
    LD_A_C = 0x79, // Load C into A
    LD_A_D = 0x7A, // Load D into A
    LD_A_E = 0x7B, // Load E into A
    LD_A_H = 0x7C, // Load H into A
    LD_A_L = 0x7D, // Load L into A
    LD_A_HL = 0x7E, // Load the memory pointed by HL into A
    LD_A_A = 0x7F, // Load A into A (NOP)

    ADD_A_B = 0x80, // Add B into A
    ADD_A_C = 0x81, // Add C into A
    ADD_A_D = 0x82, // Add D into A
    ADD_A_E = 0x83, // Add E into A
    ADD_A_H = 0x84, // Add H into A
    ADD_A_L = 0x85, // Add L into A
    ADD_A_HL= 0x86, // Add the value stored at the memory address HL into A
    ADD_A_A = 0x87, // Add A into A
    ADC_A_B = 0x88, // Add B and Carry Flag into A  
    ADC_A_C = 0x89, // Add C and Carry Flag into A 
    ADC_A_D = 0x8A, // Add D and Carry Flag into A
    ADC_A_E = 0x8B, // Add E and Carry Flag into A
    ADC_A_H = 0x8C, // Add H and Carry Flag into A
    ADC_A_L = 0x8D, // Add L and Carry Flag into A
    ADC_A_HL= 0x8E, // Add the value stored at the memory address HL and Carry Flag into A
    ADC_A_A = 0x8F, // Add A and Carry Flag into A

    SUB_A_B = 0x90, // Sub B into A
    SUB_A_C = 0x91, // Sub C into A
    SUB_A_D = 0x92, // Sub D into A
    SUB_A_E = 0x93, // Sub E into A
    SUB_A_H = 0x94, // Sub H into A
    SUB_A_L = 0x95, // Sub L into A
    SUB_A_HL= 0x96, // Sub the value stored at the memory address HL into A
    SUB_A_A = 0x97, // Sub A into A
    SBC_A_B = 0x98, // Sub B and Carry Flag into A  
    SBC_A_C = 0x99, // Sub C and Carry Flag into A 
    SBC_A_D = 0x9A, // Sub D and Carry Flag into A
    SBC_A_E = 0x9B, // Sub E and Carry Flag into A
    SBC_A_H = 0x9C, // Sub H and Carry Flag into A
    SBC_A_L = 0x9D, // Sub L and Carry Flag into A
    SBC_A_HL= 0x9E, // Sub the value stored at the memory address HL and Carry Flag into A
    SBC_A_A = 0x9F, // Sub A and Carry Flag into A

    AND_A_B = 0xA0, // And B with A
    AND_A_C = 0xA1, // And C with A
    AND_A_D = 0xA2, // And D with A
    AND_A_E = 0xA3, // And E with A
    AND_A_H = 0xA4, // And H with A
    AND_A_L = 0xA5, // And L with A
    AND_A_HL= 0xA6, // And the value stored at the memory address HL with A
    AND_A_A = 0xA7, // And A with A
    XOR_A_B = 0xA8, // Xor B with A  
    XOR_A_C = 0xA9, // Xor C with A 
    XOR_A_D = 0xAA, // Xor D with A
    XOR_A_E = 0xAB, // Xor E with A
    XOR_A_H = 0xAC, // Xor H with A
    XOR_A_L = 0xAD, // Xor L with A
    XOR_A_HL= 0xAE, // Xor the value stored at the memory address HL with A
    XOR_A_A = 0xAF, // Xor A with A

    OR_A_B = 0xB0, // Or B with A
    OR_A_C = 0xB1, // Or C with A
    OR_A_D = 0xB2, // Or D with A
    OR_A_E = 0xB3, // Or E with A
    OR_A_H = 0xB4, // Or H with A
    OR_A_L = 0xB5, // Or L with A
    OR_A_HL= 0xB6, // Or the value stored at the memory address HL with A
    OR_A_A = 0xB7, // Or A with A
    CP_A_B = 0xB8, // Compare B with A  
    CP_A_C = 0xB9, // Compare C with A 
    CP_A_D = 0xBA, // Compare D with A
    CP_A_E = 0xBB, // Compare E with A
    CP_A_H = 0xBC, // Compare H with A
    CP_A_L = 0xBD, // Compare L with A
    CP_A_HL= 0xBE, // Compare the value stored at the memory address HL with A
    CP_A_A = 0xBF, // Compare A with A    

    RET_NZ = 0xC0, // Return if Zero FLag not set
    POP_BC = 0xC1, // Pops the stack and stores the element inside BC
    JP_NZ_A16 = 0xC2, // Jumps to the 16bit address if Zero FLag is not set
    JP_A16 = 0xC3, // Jumps to the 16bit address
    CALL_NZ_A16 = 0xC4, // Calls function inside the 16bit address if Zero FLag is not set
    PUSH_BC = 0xC5, // Pushes BC to Stack
    ADD_A_N8 = 0xC6, // Adds 8bit number into A
    RST_00 = 0xC7, // Calls the function at the address 0x00
    RET_Z = 0xC8, // Returns if Zero FLag Set
    RET = 0xC9, // Pops two bytes from stack and jump to that address
    JP_Z_A16 = 0xCA, // Jumps to 16bit address if Zero FLag is set
    PREFIX = 0xCB, // Extends the Instrunction set,making it possible to access other instructions
    CALL_Z_A16 = 0xCC, // Calls function specified in the 16bit Address if Zero FLag is Set
    CALL_A16 = 0xCD, // Calls function specified in the 16bit Address
    ADC_A_N8 = 0xCE, // Add 8bit number and Carry Flag to A
    RST_08 = 0xCF, // Calls the function at the address 0x08

    RET_NC = 0xD0, // Return if Carry FLag not set
    POP_DE = 0xD1, // Pops the stack and stores the element inside DE
    JP_NC_A16 = 0xD2, // Jumps to the 16bit address if Carry FLag is not set
    ILLEGAL1 = 0xD3, // NOP
    CALL_NC_A16 = 0xD4, // Calls function inside the 16bit address if Carry FLag is not set
    PUSH_DE = 0xD5, // Pushes DE to Stack
    SUB_A_N8 = 0xD6, // Sub 8bit number into A
    RST_10 = 0xD7, // Calls the function at the address 0x10
    RET_C = 0xD8, // Returns if Carry FLag Set
    RETI = 0xD9, // Pops two bytes from stack and jump to that address and then enable interrupts
    JP_C_A16 = 0xDA, // Jumps to 16bit address if Carry Flag is set
    ILLEGAL2 = 0xDB, // NOP
    CALL_C_A16 = 0xDC, // Calls function specified in the 16bit Address if Carry FLag is Set
    ILLEGAL3 = 0xDD, // NOP
    SBC_A_N8 = 0xDE, // Sub 8bit number and Carry Flag to A
    RST_18 = 0xDF, // Calls the function at the address 0x18

    LDH_N8_A = 0xE0, // Put A into the memory address 0xFF00 + 8bit number
    POP_HL = 0xE1, // Pops the stack and stores the element inside HL
    LD_C_A = 0xE2, // Loads A into C
    ILLEGAL4 = 0xE3, // NOP
    ILLEGAL5 = 0xE4, // NOP
    PUSH_HL = 0xE5, // Push HL into Stack
    AND_A_N8 = 0xE6, // And between A and 8bit number
    RST_20 = 0xE7, // Calls the function at the address 0x20
    ADD_SP_E8 = 0xE8, // Add 8bit signed into SP
    JP_HL = 0xE9, // Jump to the address pointed by HL
    LD_A16_A = 0xEA, // Load A into 16bit address
    ILLEGAL6 = 0xEB, // NOP
    ILLEGAL7 = 0xEC, // NOP
    ILLEGAL8 = 0xED, // NOP
    XOR_A_N8 = 0xEE, // Xor between A and 8bit number
    RST_28 = 0xEF, // Calls the function at the address 0x28

    LDH_A_N8 = 0xF0, // Put the memory address 0xFF00 + 8bit number into A
    POP_AF = 0xF1, // Pops the stack and stores the element inside AF
    LD_A_C = 0xF2, // Loads C into A
    DI = 0xF3, // Disables interrupts after the next instructions executes
    ILLEGAL9 = 0xF4, // NOP
    PUSH_AF = 0xF5, // Push AF into Stack
    OR_A_N8 = 0xF6, // Or between A and 8bit number
    RST_30 = 0xF7, // Calls the function at the address 0x30
    LD_HL_SP_E8 = 0xF8, // Put SP + 8bit signed address into HL
    LD_SP_HL = 0xF9, // Jump to the address pointed by HL
    LD_A16_A = 0xFA, // Load A into 16bit address
    EI = 0xFB, // Enable Interrupts after the next instruction is executed
    ILLEGAL10 = 0xFC, // NOP
    ILLEGAL11 = 0xFD, // NOP
    CP_A_N8 = 0xFE, // Compares A with 8bit number
    RST_38 = 0xFF, // Calls the function at the address 0x38

  };
  
} // namespace Instruction
